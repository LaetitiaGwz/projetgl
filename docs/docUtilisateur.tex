\documentclass[a4,12pt]{article}

\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[babel=true]{csquotes}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{array,multirow,makecell}
\frenchbsetup{StandardLists=true}
\usepackage{enumitem}
\setlength\parindent{20pt}
\begin{document}
\begin{titlepage}
\title{ Documentation Utilisateur du compilateur Deca}
\author{Gonthier Florentin, Bergeron Matthieu, Beaupère Matthias,\\ Fischman Adrien, Geoffroy Germain}
\date{}

\maketitle

\rule[0.5ex]{\textwidth}{0.2mm}
Cette documentation destinée à un utilisateur du compilateur deca facilite la prise en main du compilateur.
Elle explique les différentes limites imposées au langage soumit au compilateur ainsi que la signification des
différentes erreurs de compilation et d'exécution. Elle propose enfin des exemples d'utilisation en exposant
le code assembleur généré par le compilateur.

\rule[0.5ex]{\textwidth}{0.2mm}

\end{titlepage}
\tableofcontents
\newpage

\section{Limitations du compilateur}

\section{Limitations de la bibliothèque math}
La classe Math contient différentes méthodes :
\begin{itemize}
    \item float ulp(float f)
    \item float sin(float f)
    \item float cos(float f)
    \item float asin(float f)
    \item float atan(float f)
\end{itemize}
Chaque méthode a été testée grâce aux valeurs retournées par les fonctions prédéfinies de Java.Math. Ces méthodes sont des approximations de valeurs mathématiques, dont on mesure la précision grâce aux ULP (Unit in the Last Place).\\
Pour une analyse complète et détaillée des algorithmes et de leurs précisions respectives, il faut se reporter à la \textbf{documentation de la classe Math}. \\
On présente ici, sous forme de tableau, les différents résultats obtenus.
\subsection{Méthode ulp.}
La méthode ulp donne le résultat exacte sans approximation.\\
\\

\hspace{-2cm}
\begin{tabular}{|c|c|c|c|c|c|}

\hline 
 & intervalle & nb erreur($>1 ulp$) & erreur max(ulp) & pas & nb tests \\
\hline 
ulp & $[0; 1\ 000]$ & 0 & $0$ & $2^{-14}$ & 16 384 000\\
\hline 
ulp & $[10\ 000; 100\ 000]$ & 0 & $0$ & $2^{-7}$ & 11 520 000\\
\hline 
ulp & $[2^{30}; 2^{31}]$ & 0 & $0$ & $128$ & 8 388 608\\
\hline
\end{tabular}

\subsection{Méthode sin.}
La méthode sin est implémenté grâce au développement en série entière de sinus et d'une réduction de Cody and Waite sur [-$\pi /8; \pi /8$].\\
La méthode sin donne une approximation à 5 ulp d'écart au maximum.\\
Pour des petits angles ($<\pi /8$), la précision est de 1 ulp dans le pire cas.\\
\\

\hspace{-4cm}\begin{tabular}{|c|c|c|c|c|c|c|}

\hline 
 & intervalle & nb erreur($>1 ulp$) & erreur max(ulp)& erreur moyenne(ulp) & pas & nb tests \\
\hline 
sin & $[0; \pi /8]$             & 0       & $1$ & null        &$2^{-23}$ & 3 294 199\\
\hline 
sin & $[\pi /8; 2\pi]$          & 1117838 & $5$ &$2.13$ & $2^{-20}$ & 6 176 623\\
\hline 
sin & $[1\ 000; 1\ 000 + 2\pi]$     & 17777    & $5$ &$2.13$ & $2^{-14}$ & 102 944\\
\hline 
sin & $[100\ 000; 100\ 000 + 2\pi]$ & 127      & $4$ &$ 2.20$ & $2^{-7}$ & 804\\
\hline
\end{tabular}

\subsection{Méthode cos.}
La méthode cos est implémenté grâce au développement en série entière de cosinus et d'une réduction de Cody and Waite sur [-$\pi /8;\pi /8$].\\
La méthode cos donne une approximation à 6 ulp d'écart au maximum.\\
Pour des petits angles ($<\pi /8$), la précision est de 2 ulp dans le pire cas.\\
\\

\hspace{-4cm}\begin{tabular}{|c|c|c|c|c|c|c|}

\hline 
 & intervalle & nb erreur($>1 ulp$) & erreur max(ulp)& erreur moyenne(ulp) & pas & nb tests \\
\hline 
cos & $[0; \pi /8]$             & 365      & $2$ & 2.0        &$2^{-23}$ & 3 294 199\\
\hline 
cos & $[\pi /8; 2\pi]$          & 1335192 & $6$ &$2.18$ & $2^{-20}$ & 6 176 623\\
\hline 
cos & $[1\ 000; 1\ 000 + 2\pi]$     & 20987    & $5$ &$2.19$ & $2^{-14}$ & 102 944\\
\hline 
cos & $[100\ 000; 100\ 000 + 2\pi]$ & 162     & $4$ &$ 2.12$ & $2^{-7}$ & 804\\
\hline
\end{tabular}

\subsection{Méthode asin.}
La méthode asin est implémenté grâce au développement en série entière de la fonction arc sin.\\
Par imparité de la fonction arcsinus, on ne donne le résultat que pour des nombres positifs.\\
La méthode asin donne une approximation à 4 ulp d'écart au maximum.\\
\\

\hspace{-3cm}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
 & intervalle & nb erreur($>1 ulp$) & erreur moyenne & erreur max(ulp) & pas & nb tests \\
\hline
asin & $[0;0.5]$ & 0 & 0 & 1 &$2^{-20}$ & 524288\\
\hline
asin & $[0.5;0.72]$ & 1974 & 2 & 2 & $2^{-20}$ & 230687\\
\hline
asin & $[0.72;0.98]$ & 22660 & 2.12 & 4 & $2^{-20}$ & 272630\\
\hline
asin & $[0.98;1]$ & 1687 & 2.43 & 7 & $2^{-20}$ & 20972\\
\hline
\end{tabular}

\subsection{Méthode atan.}
La méthode atan est implémenté grâce aux polynômes de Hermite.\\
Par imparité de la fonction arctangente, on ne donne le résultat que pour des nombres positifs.\\
La méthode atan donne une approximation à 2 ulp d'écart au maximum.\\
\\

\hspace{-3cm}
\begin{tabular}{|c|c|c|c|c|c|c|}

\hline
 & intervalle & nb erreur($>1 ulp$) & erreur moyenne & erreur max(ulp) & pas & nb tests \\
\hline
atan & $[0; 0.6875]$ & 0 & 0 & 1 &$2^{-20}$ & 720 896\\
\hline
atan & $[0.6875; 1.1875]$ & 0 & 0 & 1 & $2^{-20}$ & 524 288\\
\hline
atan & $[0.1875; 2]$ & 43 006 & 2.0 & 2.0 & $2^{-23}$ & 6 815 744\\
\hline
atan & $[2; 100]$ & 0 & 0 & 1.0 & $2^{-12}$ & 401 408\\
\hline
atan & $[100; 10\ 000]$ & 0 & 0 & 1.0 & $2^{-7}$ & 1 267 200\\
\hline
\end{tabular}
\section{Recensement des erreurs}

\subsection{Erreur de lexicographie}
\begin{tabular}{|l|l|l|}
\hline
   Description de l'erreur & Exemple & Résultat \\
   \hline
   blabla & int a = 5.3/0.0 & Lexer error...  \\
   \hline
\end{tabular}
\subsection{Erreur de syntaxe hors-contexte}


\subsection{Erreur de syntaxe contextuelle}

\textbf{Cannot override method <method name> with a different signature.} \\
Tentative de sucharge d'une méthode de superclasse avec une signature différente.
\begin{lstlisting}
   class A {
      void m() {}
   }
   class B exends A {
      void m(int a) {}
   }
\end{lstlisting}



\textbf{Type returned by method <method name> is not a subtype of overrided method.}\\
Une méthode est redéfinie mais le type renvoyé n'est pas un sous-type de la méthode initiale.
\begin{lstlisting}
   class A {
      int m() {}
   }
   class B exends A {
      boolean m() {}
   }
\end{lstlisting}



\textbf{Double declaration of method <method name>}\\
Un méthode est déclarée deux fois dans la même classe.
\begin{lstlisting}
   class A {
      int m() {}
      int m() {}
   }
\end{lstlisting}



\textbf{Condition must be a boolean.}\\
La condition donnée n'est pas un booléen.
\begin{lstlisting}
{
   while(5) {}
}
\end{lstlisting}



\textbf{Arithmetic operation on expressions which types are differents.}\\
Les deux opérande de l'opération ne sont pas de même type, et il ne s'agit pas d'un entier et d'un flottant.
\begin{lstlisting}
{
   int a = 5 + false;
}
\end{lstlisting}



\textbf{Boolean operation on non-boolean operands.}\\
L'un des opérande de l'opération booléenne n'est pas un booléen.
\begin{lstlisting}
{
   boolean x = false || 5;
}
\end{lstlisting}



\textbf{Inequality on non-numbers.}\\
L'un des opérande de l'inégalité n'est pas un nombre.
\begin{lstlisting}
{
   boolean x = 5 == true;
}
\end{lstlisting}



\textbf{Cannot assign <right type> to <left type>}\\

\begin{lstlisting}

\end{lstlisting}



\textbf{Incompatible cast from <operand type> to <cast type>}\\
Impossible d'effectuer le cast de la variable de type <cast type> en une variable de type <cast type>.
\begin{lstlisting}
{
   int a = (int)5.2;
}
\end{lstlisting}



\textbf{Class " + name.getName().getName() + " twice declared.}\\

\begin{lstlisting}

\end{lstlisting}



\textbf{Name " + getVarName().getName().getName() + " already used in the class.}\\

\begin{lstlisting}

\end{lstlisting}



\textbf{"Double definition of variable " + varName.getName().getName()}\\

\begin{lstlisting}

\end{lstlisting}



\textbf{Multiple declaration of variable " + getVarName()}\\

\begin{lstlisting}

\end{lstlisting}



\textbf{A variable can not be declared as void.}\\

\begin{lstlisting}

\end{lstlisting}



\textbf{Undefinded variable " + getName()}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{A variable can not be declared as void.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Type " + getName().getName() + " undefinded.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Class " + getName().getName() + " undefinded.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Method " + getName().getName() + " undefinded.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Invalid signature for method " + getName().getName()}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Incompatible type initialization.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Wrong argument number.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Wrong type for param " + i}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Not and instance of a class given for method call.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Modulo must be used with two int.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Must apply 'not' operator to a boolean.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Return type does not match definition.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Not and instance of a class given for selection.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Cannot call a protected field outside its class or a subclass.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Cannot use 'this' in main.}\\

\begin{lstlisting}

\end{lstlisting}




\textbf{Must apply unary minus to an int or float.}\\

\begin{lstlisting}

\end{lstlisting}



\subsection{Erreur à l'éxécution}
\begin{tabular}{|l|l|l|}
\hline
   Description de l'erreur & Exemple & Résultat \\
   \hline
   Débordement arithmétique & int a = 5.3/0.0 & Error : overflow during arithmetic operation  \\
   \hline
\end{tabular}

\section{Exemples}
\subsection{Hello World}

\textbf{Code deca :} 
\begin{verbatim}
	{
        println("Hello");
	}
\end{verbatim}
\textbf{Code assembleur :} 
\begin{verbatim}
; start main program
	TSTO #4
	BOV stack_overflow
	ADDSP #4
	LOAD #null, R0
	STORE R0, 1(GB)
	LOAD code.Object.equals, R0
	STORE R0, 2(GB)
; Main program
; Beginning of main instructions:
	WSTR "Hello"
	WNL
	HALT
init.Object:
	RTS
code.Object.equals:
	TSTO #2
	BOV stack_overflow
	PUSH R2
	PUSH R3
	LOAD -2(LB), R2
	LOAD -3(LB), R3
	CMP R2, R3
	SEQ R0
	POP R3
	POP R2
	RTS
; end main program
arith_overflow:
	WSTR "Error : overflow during arithmetic operation"
	ERROR
stack_overflow:
	WSTR "Error : stack overflow"
	ERROR
heap_overflow:
	WSTR "Error : heap overflow"
	ERROR
dereferencement.null:
	WSTR "Error : dereferencing null pointer"
	ERROR
\end{verbatim}

\subsection{Fibonacci itératif}
\textbf{Code deca :} 
\begin{verbatim}
{
    int n = 25;
    int i = 1;
    int first = 0;
    int second = 1;
    int tmp;
    while(i <= n){
        tmp = first + second;
        first = second;
        second = tmp;
        i = i + 1;
    }
    print(first);
}
\end{verbatim}
\textbf{Code assembleur :} 
\begin{verbatim}
; start main program
	TSTO #9
	BOV stack_overflow
	ADDSP #9
	LOAD #null, R0
	STORE R0, 1(GB)
	LOAD code.Object.equals, R0
	STORE R0, 2(GB)
; Main program
	LOAD #25, R2
	STORE R2, 3(GB)
	LOAD #1, R3
	STORE R3, 4(GB)
	LOAD #0, R4
	STORE R4, 5(GB)
	LOAD #1, R5
	STORE R5, 6(GB)
; Beginning of main instructions:
DebutWhile0:
	LOAD 4(GB), R0
	LOAD 3(GB), R1
	CMP R1, R0
	BGT EndWhile0
	LOAD 5(GB), R6
	ADD 6(GB), R6
	STORE R6, 7(GB)
	LOAD 6(GB), R2
	STORE R2, 5(GB)
	LOAD 7(GB), R2
	STORE R2, 6(GB)
	LOAD 4(GB), R2
	ADD #1, R2
	STORE R2, 4(GB)
	BRA DebutWhile0
EndWhile0:
	LOAD 5(GB), R1
	WINT
	HALT
init.Object:
	RTS
code.Object.equals:
	TSTO #2
	BOV stack_overflow
	PUSH R2
	PUSH R3
	LOAD -2(LB), R2
	LOAD -3(LB), R3
	CMP R2, R3
	SEQ R0
	POP R3
	POP R2
	RTS
; end main program
arith_overflow:
	WSTR "Error : overflow during arithmetic operation"
	ERROR
stack_overflow:
	WSTR "Error : stack overflow"
	ERROR
heap_overflow:
	WSTR "Error : heap overflow"
	ERROR
dereferencement.null:
	WSTR "Error : dereferencing null pointer"
	ERROR
\end{verbatim}
\subsection{Grosse expression et option -r 4}
Nous testons ici le bon fonctionnement de l'option -r qui permet de limiter le nombre de registres disponibles. On remarque que l'option fonctionne correctement, puisqu'aucun registre supérieur à R3 n'est utilisé. L'expression est aussi correctement évaluée à 94. \\
\textbf{Code deca :} 
\begin{verbatim}
{
    int a = ( ( (5 + (3 % 1)) - 2 + ((2 - 2 + 3)*5 + 2 - 2) + (1 - 1) - (1/3 + 54) + 2
    - ( 2 + 3*2*3*(9*10/11)) + 1 - 8) % 4
    *
    ( (5 + (3 % 1)) - 2 + ((2 - 2 + 3)*5 + 2 - 2) + (1 - 1) - (1/3 + 54) + 2
    - ( 2 + 3*2*3*(9*10/11)) + 1 - 8) % 4
    -
    ( (5 + (3 % 1)) - 2 + ((2 - 2 + 3)*5 + 2 - 2) + (1 - 1) - (1/3 + 54) + 2
    - ( 2 + 3*2*3*(9*10/11)) + 1 - 8) % 4
    + (2*23*3 - 1)
    ) / ( (23%2) + 2*2*(2-(3*(4-3+1-1))))
    *
     (( (5 + (3 % 1)) - 1 + ((2 - 2 + 3)*5 + 2 - 2) + (1 - 1) - (1/3 + 54) + 2
    - ( 2 + 3*2*3*(9*10/11)) + 1 - 8) % 4) ;
    print(a);
}
\end{verbatim}
\textbf{Code assembleur :} 
\begin{verbatim}
; start main program
	TSTO #5
	BOV stack_overflow
	ADDSP #5
	LOAD #null, R0
	STORE R0, 1(GB)
	LOAD code.Object.equals, R0
	STORE R0, 2(GB)
; Main program
	LOAD #5, R2
	LOAD #3, R3
	REM #1, R3
	BOV arith_overflow
	ADD R3, R2
	SUB #2, R2
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #2, R3
	SUB #2, R3
	ADD #3, R3
	MUL #5, R3
	ADD #2, R3
	SUB #2, R3
	ADD R3, R2
	POP R3
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #1, R3
	SUB #1, R3
	ADD R3, R2
	POP R3
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #1, R3
	QUO #3, R3
	BOV arith_overflow
	ADD #54, R3
	SUB R3, R2
	POP R3
	ADD #2, R2
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #2, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #3, R2
	MUL #2, R2
	MUL #3, R2
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #9, R3
	MUL #10, R3
	QUO #11, R3
	BOV arith_overflow
	MUL R3, R2
	POP R3
	ADD R2, R3
	POP R2
	SUB R3, R2
	POP R3
	ADD #1, R2
	SUB #8, R2
	REM #4, R2
	BOV arith_overflow
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #5, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #3, R2
	REM #1, R2
	BOV arith_overflow
	ADD R2, R3
	POP R2
	SUB #2, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #2, R2
	SUB #2, R2
	ADD #3, R2
	MUL #5, R2
	ADD #2, R2
	SUB #2, R2
	ADD R2, R3
	POP R2
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #1, R2
	SUB #1, R2
	ADD R2, R3
	POP R2
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #1, R2
	QUO #3, R2
	BOV arith_overflow
	ADD #54, R2
	SUB R2, R3
	POP R2
	ADD #2, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #2, R2
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #3, R3
	MUL #2, R3
	MUL #3, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #9, R2
	MUL #10, R2
	QUO #11, R2
	BOV arith_overflow
	MUL R2, R3
	POP R2
	ADD R3, R2
	POP R3
	SUB R2, R3
	POP R2
	ADD #1, R3
	SUB #8, R3
	MUL R3, R2
	POP R3
	REM #4, R2
	BOV arith_overflow
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #5, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #3, R2
	REM #1, R2
	BOV arith_overflow
	ADD R2, R3
	POP R2
	SUB #2, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #2, R2
	SUB #2, R2
	ADD #3, R2
	MUL #5, R2
	ADD #2, R2
	SUB #2, R2
	ADD R2, R3
	POP R2
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #1, R2
	SUB #1, R2
	ADD R2, R3
	POP R2
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #1, R2
	QUO #3, R2
	BOV arith_overflow
	ADD #54, R2
	SUB R2, R3
	POP R2
	ADD #2, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #2, R2
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #3, R3
	MUL #2, R3
	MUL #3, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #9, R2
	MUL #10, R2
	QUO #11, R2
	BOV arith_overflow
	MUL R2, R3
	POP R2
	ADD R3, R2
	POP R3
	SUB R2, R3
	POP R2
	ADD #1, R3
	SUB #8, R3
	REM #4, R3
	BOV arith_overflow
	SUB R3, R2
	POP R3
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #2, R3
	MUL #23, R3
	MUL #3, R3
	SUB #1, R3
	ADD R3, R2
	POP R3
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #23, R3
	REM #2, R3
	BOV arith_overflow
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #2, R2
	MUL #2, R2
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #2, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #3, R2
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #4, R3
	SUB #3, R3
	ADD #1, R3
	SUB #1, R3
	MUL R3, R2
	POP R3
	SUB R2, R3
	POP R2
	MUL R3, R2
	POP R3
	ADD R2, R3
	POP R2
	QUO R3, R2
	BOV arith_overflow
	POP R3
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #5, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #3, R2
	REM #1, R2
	BOV arith_overflow
	ADD R2, R3
	POP R2
	SUB #1, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #2, R2
	SUB #2, R2
	ADD #3, R2
	MUL #5, R2
	ADD #2, R2
	SUB #2, R2
	ADD R2, R3
	POP R2
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #1, R2
	SUB #1, R2
	ADD R2, R3
	POP R2
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #1, R2
	QUO #3, R2
	BOV arith_overflow
	ADD #54, R2
	SUB R2, R3
	POP R2
	ADD #2, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #2, R2
	TSTO #1
	BOV stack_overflow
	PUSH R3
	LOAD #3, R3
	MUL #2, R3
	MUL #3, R3
	TSTO #1
	BOV stack_overflow
	PUSH R2
	LOAD #9, R2
	MUL #10, R2
	QUO #11, R2
	BOV arith_overflow
	MUL R2, R3
	POP R2
	ADD R3, R2
	POP R3
	SUB R2, R3
	POP R2
	ADD #1, R3
	SUB #8, R3
	REM #4, R3
	BOV arith_overflow
	MUL R3, R2
	POP R3
	STORE R2, 3(GB)
; Beginning of main instructions:
	LOAD 3(GB), R1
	WINT
	HALT
init.Object:
	RTS
code.Object.equals:
	TSTO #2
	BOV stack_overflow
	PUSH R2
	PUSH R3
	LOAD -2(LB), R2
	LOAD -3(LB), R3
	CMP R2, R3
	SEQ R0
	POP R3
	POP R2
	RTS
; end main program
arith_overflow:
	WSTR "Error : overflow during arithmetic operation"
	ERROR
stack_overflow:
	WSTR "Error : stack overflow"
	ERROR
heap_overflow:
	WSTR "Error : heap overflow"
	ERROR
dereferencement.null:
	WSTR "Error : dereferencing null pointer"
	ERROR
\end{verbatim}

\end{document}
